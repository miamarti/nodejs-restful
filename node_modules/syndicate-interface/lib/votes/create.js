
/**
 * Create a vote.
 * Unlike other types of collections, we always keep a history of votes.
 * This is because how a users' votes change over time is important!
 * We don't care how bookmarks change over time.
 */

var assert = require('assert')

var redis = require('../databases/redis')
var mdb = require('../databases/mongodb')
var syndicate = require('../syndicate')
var values = require('./values.json')

module.exports = function* (options) {
  var user = options.user
  var thing = options.thing
  var value = options.value
  var type = options.type
  var multiplier = 1
  var weight = 1

  assert(values[type] && value in values[type])

  var promises = []

  // cache votes on the user
  promises.push(mdb.users.findOne({
    _id: user._id
  }).set(['cache', thing._id.toHexString(), 'vote', type].join(','), value))

  // add the votes in the database
  promises.push(mdb.votes.insert({
    user: {
      _id: user._id,
    },
    thing: {
      _id: thing._id,
      collection: thing.collection
    },
    value: value,
    type: type,
    multiplier: multiplier,
    weight: weight,
    'date.created': new Date()
  }))

  var user_id = user._id.toHexString()
  var thing_id = thing._id.toHexString()
  var voter_pos_key = 'voter:pos:' + type + ':' + user_id
  var voter_neg_key = 'voter:neg:' + type + ':' + user_id
  var votee_pos_key = 'votee:pos:' + type + ':' + thing_id
  var votee_neg_key = 'votee:neg:' + type + ':' + thing_id
  value = values[type][value]
  if (value > 0) {
    promises.push(redis.zadd(voter_pos_key, Date.now(), thing_id))
    promises.push(redis.zadd(votee_pos_key, Date.now(), user_id))
  } else {
    promises.push(redis.zrem(voter_pos_key, thing_id))
    promises.push(redis.zrem(votee_pos_key, user_id))
  }
  if (value < 0) {
    promises.push(redis.zadd(voter_neg_key, Date.now(), thing_id))
    promises.push(redis.zadd(votee_neg_key, Date.now(), user_id))
  } else {
    promises.push(redis.zrem(voter_neg_key, thing_id))
    promises.push(redis.zrem(votee_neg_key, user_id))
  }

  yield promises

  syndicate.emit('vote', options)
}
